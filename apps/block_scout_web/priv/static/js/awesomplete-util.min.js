/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!************************************!*\
  !*** ./js/lib/awesomplete-util.js ***!
  \************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
eval("/* eslint-env browser */\n/* global Awesomplete */\n/* exported AwesompleteUtil */\n\n/*\n * Library endorsing Lea Verou's Awesomplete widget, providing:\n * - dynamic remote data loading\n * - labels with HTML markup\n * - events and styling for exact matches\n * - events and styling for mismatches\n * - select item when TAB key is used\n *\n * (c) Nico Hoogervorst\n * License: MIT\n *\n */\nwindow.AwesompleteUtil = (function () {\n  //\n  // event names and css classes\n  //\n  var _AWE = 'awesomplete-'\n  var _AWE_LOAD = _AWE + 'loadcomplete'\n  var _AWE_CLOSE = _AWE + 'close'\n  var _AWE_MATCH = _AWE + 'match'\n  var _AWE_PREPOP = _AWE + 'prepop'\n  var _AWE_SELECT = _AWE + 'select'\n  var _CLS_FOUND = 'awe-found'\n  var _CLS_NOT_FOUND = 'awe-not-found'\n  var $ = Awesomplete.$ /* shortcut for document.querySelector */\n\n  //\n  // private functions\n  //\n\n  // Some parts are shamelessly copied from Awesomplete.js like the logic inside this _suggestion function.\n  // Returns an object with label and value properties. Data parameter is plain text or Object/Array with label and value.\n  function _suggestion (data) {\n    var lv = Array.isArray(data)\n      ? { label: data[0], value: data[1] }\n      : typeof data === 'object' && 'label' in data && 'value' in data ? data : { label: data, value: data }\n    return { label: lv.label || lv.value, value: lv.value }\n  }\n\n  // Helper to send events with detail property.\n  function _fire (target, name, detail) {\n    // $.fire uses deprecated methods but other methods don't work in IE11.\n    return $.fire(target, name, { detail: detail })\n  }\n\n  // Look if there is an exact match or a mismatch, set awe-found, awe-not-found css class and send match events.\n  function _matchValue (awe, prepop) {\n    var input = awe.input /* the input field */\n    var classList = input.classList\n    var utilprops = awe.utilprops /* extra properties piggybacked on Awesomplete object */\n    var selected = utilprops.selected /* the exact selected Suggestion with label and value */\n    var val = utilprops.convertInput.call(awe, input.value) /* trimmed lowercased value */\n    var opened = awe.opened /* is the suggestion list opened? */\n    var result = [] /* matches with value */\n    var list = awe._list /* current list of suggestions */\n    var suggestion, fake, rec, j /* function scoped variables */\n    utilprops.prepop = false /* after the first call it's not a prepopulation phase anymore */\n    if (list) { /* if there is a suggestion list */\n      for (j = 0; j < list.length; j++) { /* loop all suggestions */\n        rec = list[j]\n        suggestion = _suggestion(awe.data(rec, val)) /* call data convert function */\n        // with maxItems = 0 cannot look if suggestion list is opened to determine if there are still matches,\n        // instead call the filter method to see if there are still some options.\n        if (awe.maxItems === 0) {\n          // Awesomplete.FILTER_CONTAINS and Awesomplete.FILTER_STARTSWITH use the toString method.\n          suggestion.toString = function () { return '' + this.label }\n          if (awe.filter(suggestion, val)) {\n            // filter returns true, so there is at least one partial match.\n            opened = true\n          }\n        }\n        // Don't want to change the real input field, emulate a fake one.\n        fake = { input: { value: '' } }\n        // Determine how this suggestion would look like if it is replaced in the input field,\n        // it is an exact match if somebody types exactly that.\n        // Use the fake input here. fake.input.value will contain the result of the replace function.\n        awe.replace.call(fake, suggestion)\n        // Trim and lowercase also the fake input and compare that with the currently typed-in value.\n        if (utilprops.convertInput.call(awe, fake.input.value) === val) {\n          // This is an exact match. However there might more suggestions with the same value.\n          // If the user selected a suggestion from the list, check if this one matches, assuming that\n          // value + label is unique (if not it will be difficult for the user to make an informed decision).\n          if (selected && selected.value === suggestion.value && selected.label === suggestion.label) {\n            // this surely is the selected one\n            result = [rec]\n            break\n          }\n          // add the matching record to the result set.\n          result.push(rec)\n        } // end if\n      } // end loop\n\n      // if the result differs from the previous result\n      if (utilprops.prevSelected !== result) {\n        // if there is an exact match\n        if (result.length > 0) {\n          // if prepopulation phase (initial/autofill value); not triggered by user input\n          if (prepop) {\n            _fire(input, _AWE_PREPOP, result)\n          } else if (utilprops.changed) { /* if input is changed */\n            utilprops.prevSelected = result /* new result      */\n            classList.remove(_CLS_NOT_FOUND) /* remove class   */\n            classList.add(_CLS_FOUND) /* add css class */\n            _fire(input, _AWE_MATCH, result) /* fire event   */\n          }\n        } else if (prepop) { /* no exact match, if in prepopulation phase */\n          _fire(input, _AWE_PREPOP, [])\n        } else if (utilprops.changed) { /* no exact match, if input is changed */\n          utilprops.prevSelected = []\n          classList.remove(_CLS_FOUND)\n          // Mark as not-found if there are no suggestions anymore or if another field is now active\n          if (!opened || (input !== document.activeElement)) {\n            if (val.length > 0) {\n              classList.add(_CLS_NOT_FOUND)\n              _fire(input, _AWE_MATCH, [])\n            }\n          } else {\n            classList.remove(_CLS_NOT_FOUND)\n          }\n        }\n      }\n    }\n  }\n\n  // Listen to certain events of THIS awesomplete object to trigger input validation.\n  function _match (ev) {\n    var awe = this\n    if ((ev.type === _AWE_CLOSE || ev.type === _AWE_LOAD || ev.type === 'blur') && ev.target === awe.input) {\n      _matchValue(awe, awe.utilprops.prepop && ev.type === _AWE_LOAD)\n    }\n  }\n\n  // Select currently selected item if tab or shift-tab key is used.\n  function _onKeydown (ev) {\n    var awe = this\n    if (ev.target === awe.input && ev.keyCode === 9) { // TAB key\n      awe.select() // take current selected item\n    }\n  }\n\n  // Handle selection event. State changes when an item is selected.\n  function _select (ev) {\n    var awe = this\n    awe.utilprops.changed = true // yes, user made a change\n    awe.utilprops.selected = ev.text // Suggestion object\n    const address = ev.text.split(/<p>/)[0]\n    window.open(`/search?q=${address}`, '_self')\n  }\n\n  // check if the object is empty {} object\n  function _isEmpty (val) {\n    return Object.keys(val).length === 0 && val.constructor === Object\n  }\n\n  // Need an updated suggestion list if:\n  // - There is no result yet, or there is a result but not for the characters we entered\n  // - or there might be more specific results because the limit was reached.\n  function _ifNeedListUpdate (awe, val, queryVal) {\n    var utilprops = awe.utilprops\n    return (!utilprops.listQuery ||\n                  (!utilprops.loadall && /* with loadall, if there is a result, there is no need for new lists */\n                   val.lastIndexOf(queryVal, 0) === 0 &&\n                   (val.lastIndexOf(utilprops.listQuery, 0) !== 0 ||\n                     (typeof utilprops.limit === 'number' && awe._list.length >= utilprops.limit))))\n  }\n\n  // Set a new suggestion list. Trigger loadcomplete event.\n  function _loadComplete (awe, list, queryVal) {\n    awe.list = list\n    awe.utilprops.listQuery = queryVal\n    _fire(awe.input, _AWE_LOAD, queryVal)\n  }\n\n  // Handle ajax response. Expects HTTP OK (200) response with JSON object with suggestion(s) (array).\n  function _onLoad () {\n    var t = this\n    var awe = t.awe\n    var xhr = t.xhr\n    var queryVal = t.queryVal\n    var val = awe.utilprops.val\n    var data\n    var prop\n    if (xhr.status === 200) {\n      data = JSON.parse(xhr.responseText)\n      if (awe.utilprops.convertResponse) data = awe.utilprops.convertResponse(data)\n      if (!Array.isArray(data)) {\n        if (awe.utilprops.limit === 0 || awe.utilprops.limit === 1) {\n          // if there is max 1 result expected, the array is not needed.\n          // Fur further processing, take the whole result and put it as one element in an array.\n          data = _isEmpty(data) ? [] : [data]\n        } else {\n          // search for the first property that contains an array\n          for (prop in data) {\n            if (Array.isArray(data[prop])) {\n              data = data[prop]\n              break\n            }\n          }\n        }\n      }\n      // can only handle arrays\n      if (Array.isArray(data)) {\n        // are we still interested in this response?\n        if (_ifNeedListUpdate(awe, val, queryVal)) {\n          // accept the new suggestion list\n          _loadComplete(awe, data, queryVal || awe.utilprops.loadall)\n        }\n      }\n    }\n  }\n\n  // Perform suggestion list lookup for the current value and validate. Use ajax when there is an url specified.\n  function _lookup (awe, val) {\n    var xhr\n    if (awe.utilprops.url) {\n      // are we still interested in this response?\n      if (_ifNeedListUpdate(awe, val, val)) {\n        xhr = new XMLHttpRequest()\n        awe.utilprops.ajax.call(awe,\n          awe.utilprops.url,\n          awe.utilprops.urlEnd,\n          awe.utilprops.loadall ? '' : val,\n          _onLoad.bind({ awe: awe, xhr: xhr, queryVal: val }),\n          xhr\n        )\n      } else {\n        _matchValue(awe, awe.utilprops.prepop)\n      }\n    } else {\n      _matchValue(awe, awe.utilprops.prepop)\n    }\n  }\n\n  // Restart autocomplete search: clear css classes and send match-event with empty list.\n  function _restart (awe) {\n    var elem = awe.input\n    var classList = elem.classList\n    // IE11 only handles the first parameter of the remove method.\n    classList.remove(_CLS_NOT_FOUND)\n    classList.remove(_CLS_FOUND)\n    _fire(elem, _AWE_MATCH, [])\n  }\n\n  // handle new input value\n  function _update (awe, val, prepop) {\n    // prepop parameter is optional. Default value is false.\n    awe.utilprops.prepop = prepop || false\n    // if value changed\n    if (awe.utilprops.val !== val) {\n      // new value, clear previous selection\n      awe.utilprops.selected = null\n      // yes, user made a change\n      awe.utilprops.changed = true\n      awe.utilprops.val = val\n      // value is empty or smaller than minChars\n      if (val.length < awe.minChars || val.length === 0) {\n        // restart autocomplete search\n        _restart(awe)\n      }\n      if (val.length >= awe.minChars) {\n        // lookup suggestions and validate input\n        _lookup(awe, val)\n      }\n    }\n    return awe\n  }\n\n  // handle input changed event for THIS awesomplete object\n  function _onInput (e) {\n    var awe = this\n    var val\n    if (e.target === awe.input) {\n      // lowercase and trim input value\n      val = awe.utilprops.convertInput.call(awe, awe.input.value)\n      _update(awe, val)\n    }\n  }\n\n  // item function (as specified in Awesomplete) which just creates the 'li' HTML tag.\n  function _item (html /* , input */) {\n    return $.create('li', {\n      innerHTML: html,\n      'aria-selected': 'false'\n    })\n  }\n\n  // Escape HTML characters in text.\n  function _htmlEscape (text) {\n    return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n  }\n\n  // Function to copy a field from the selected autocomplete item to another DOM element.\n  function _copyFun (e) {\n    var t = this\n    var sourceId = t.sourceId\n    var dataField = t.dataField\n    var targetId = t.targetId\n    var elem\n    var val\n    if (e.target === $(sourceId)) {\n      if (typeof targetId === 'function') {\n        targetId(e, dataField)\n      } else {\n        // lookup target element if it isn't resolved yet\n        elem = $(targetId)\n        // don't override target inputs if user is currently editing it.\n        if (elem && elem !== document.activeElement) {\n          // event must contain 1 item from suggestion list\n          val = Array.isArray(e.detail) && e.detail.length === 1 ? e.detail[0] : null\n          // if a datafield is specified, take that value\n          val = (dataField && val ? val[dataField] : val) || ''\n          // if it is an input control\n          if (typeof elem.value !== 'undefined') {\n            // set new value\n            elem.value = val\n            // not really sure if it is an input control, check if it has a classList\n            if (elem.classList && elem.classList.remove) {\n              // it might be another awesomplete control, if so the input is not wrong anymore because it's changed now\n              elem.classList.remove(_CLS_NOT_FOUND)\n            }\n          } else if (typeof elem.src !== 'undefined') { /* is it an image tag? */\n            elem.src = val\n          } else {\n            // use innerHTML to set the new value, because value might intentionally contain HTML markup\n            elem.innerHTML = val\n          }\n        }\n      }\n    }\n  }\n\n  // click function for the combobox button\n  function _clickFun (e) {\n    var t = this\n    var awe\n    var minChars\n    if (e.target === $(t.btnId)) {\n      e.preventDefault()\n      awe = t.awe\n      // toggle open/close\n      if (awe.ul.childNodes.length === 0 || awe.ul.hasAttribute('hidden')) {\n        minChars = awe.minChars\n        // ignore that the input value is empty\n        awe.minChars = 0\n        // show the suggestion list\n        awe.evaluate()\n        awe.minChars = minChars\n      } else {\n        awe.close()\n      }\n    }\n  }\n\n  // Return text with mark tags arround matching input. Don't replace inside <HTML> tags.\n  // When startsWith is true, mark only the matching begin text.\n  function _mark (text, input, startsWith) {\n    var searchText = $.regExpEscape(_htmlEscape(input).trim())\n    var regExp = searchText.length <= 0 ? null : startsWith ? RegExp('^' + searchText, 'i') : RegExp('(?!<[^>]+?>)' + searchText + '(?![^<]*?>)', 'gi')\n    return text.replace(regExp, '<mark>$&</mark>')\n  }\n\n  // Recursive jsonFlatten function\n  function _jsonFlatten (result, cur, prop, level, opts) {\n    var root = opts.root /* filter resulting json tree on root property (optional) */\n    var value = opts.value /* search for this property and copy it's value to a new 'value' property\n                                     (optional, do not specify it if the json array contains plain strings) */\n    var label = opts.label || opts.value /* search this property and copy it's value to a new 'label' property.\n                                     If there is a 'opts.value' field but no 'opts.label', assume label is the same. */\n    var isEmpty = true\n    var arrayResult = []\n    var j\n    // at top level, look if there is a property which starts with root (if specified)\n    if (level === 0 && root && prop && (prop + '.').lastIndexOf(root + '.', 0) !== 0 && (root + '.').lastIndexOf(prop + '.', 0) !== 0) {\n      return result\n    }\n    // handle current part of the json tree\n    if (Object(cur) !== cur) {\n      if (prop) {\n        result[prop] = cur\n      } else {\n        result = cur\n      }\n    } else if (Array.isArray(cur)) {\n      for (j = 0; j < cur.length; j++) {\n        arrayResult.push(_jsonFlatten({}, cur[j], '', level + 1, opts))\n      }\n      if (prop) {\n        result[prop] = arrayResult\n      } else {\n        result = arrayResult\n      }\n    } else {\n      for (j in cur) {\n        isEmpty = false\n        _jsonFlatten(result, cur[j], prop ? prop + '.' + j : j, level, opts)\n      }\n      if (isEmpty && prop) result[prop] = {}\n    }\n    // for arrays at top and subtop level\n    if (level < 2 && prop) {\n      // if a 'value' is specified and found a mathing property, create extra 'value' property.\n      if (value && (prop + '.').lastIndexOf(value + '.', 0) === 0) { result.value = result[prop] }\n      // if a 'label' is specified and found a mathing property, create extra 'label' property.\n      if (label && (prop + '.').lastIndexOf(label + '.', 0) === 0) { result.label = result[prop] }\n    }\n    if (level === 0) {\n      // Make sure that both value and label properties exist, even if they are nil.\n      // This is handy with limit 0 or 1 when the result doesn't have to contain an array.\n      if (value && !('value' in result)) { result.value = null }\n      if (label && !('label' in result)) { result.label = null }\n    }\n    return result\n  }\n\n  // Stop AwesompleteUtil; detach event handlers from the Awesomplete object.\n  function _detach () {\n    var t = this\n    var elem = t.awe.input\n    var boundMatch = t.boundMatch\n    var boundOnInput = t.boundOnInput\n    var boundOnKeydown = t.boundOnKeydown\n    var boundSelect = t.boundSelect\n\n    elem.removeEventListener(_AWE_SELECT, boundSelect)\n    elem.removeEventListener(_AWE_LOAD, boundMatch)\n    elem.removeEventListener(_AWE_CLOSE, boundMatch)\n    elem.removeEventListener('blur', boundMatch)\n    elem.removeEventListener('input', boundOnInput)\n    elem.removeEventListener('keydown', boundOnKeydown)\n  }\n\n  //\n  // public methods\n  //\n\n  return {\n\n    // ajax call for url + val + urlEnd. fn is the callback function. xhr parameter is optional.\n    ajax: function (url, urlEnd, val, fn, xhr) {\n      xhr = xhr || new XMLHttpRequest()\n      xhr.open('GET', url + encodeURIComponent(val) + (urlEnd || ''))\n      xhr.onload = fn\n      xhr.send()\n      return xhr\n    },\n\n    // Convert input before comparing it with suggestion. lowercase and trim the text\n    convertInput: function (text) {\n      return typeof text === 'string' ? text.trim().toLowerCase() : ''\n    },\n\n    // item function as defined in Awesomplete.\n    // item(html, input). input is optional and ignored in this implementation\n    item: _item,\n\n    // Set a new suggestion list. Trigger loadcomplete event.\n    // load(awesomplete, list, queryVal)\n    load: _loadComplete,\n\n    // Return text with mark tags arround matching input. Don't replace inside <HTML> tags.\n    // When startsWith is true, mark only the matching begin text.\n    // mark(text, input, startsWith)\n    mark: _mark,\n\n    // highlight items: Marks input in the first line, not in the optional description\n    itemContains: function (text, input) {\n      var arr\n      if (input.trim().length > 0) {\n        arr = ('' + text).split(/<p>/)\n        arr[0] = _mark(arr[0], input)\n        text = arr.join('<p>')\n      }\n      return _item(text, input)\n    },\n\n    // highlight items: mark all occurrences of the input text\n    itemMarkAll: function (text, input) {\n      return _item(input.trim() === '' ? '' + text : _mark('' + text, input), input)\n    },\n\n    // highlight items: mark input in the begin text\n    itemStartsWith: function (text, input) {\n      return _item(input.trim() === '' ? '' + text : _mark('' + text, input, true), input)\n    },\n\n    // create Awesomplete object for input control elemId. opts are passed unchanged to Awesomplete.\n    create: function (elemId, utilOpts, opts) {\n      opts.item = opts.item || this.itemContains /* by default uses itemContains, can be overriden */\n      var awe = new Awesomplete(elemId, opts)\n      awe.utilprops = utilOpts || {}\n      // loadall is true if there is no url (there is a static data-list)\n      if (!awe.utilprops.url && typeof awe.utilprops.loadall === 'undefined') {\n        awe.utilprops.loadall = true\n      }\n      awe.utilprops.ajax = awe.utilprops.ajax || this.ajax /* default ajax function can be overriden */\n      awe.utilprops.convertInput = awe.utilprops.convertInput || this.convertInput /* the same applies for convertInput */\n      return awe\n    },\n\n    // attach Awesomplete object to event listeners\n    attach: function (awe) {\n      var elem = awe.input\n      var boundMatch = _match.bind(awe)\n      var boundOnKeydown = _onKeydown.bind(awe)\n      var boundOnInput = _onInput.bind(awe)\n      var boundSelect = _select.bind(awe)\n      var boundDetach = _detach.bind({\n        awe: awe,\n        boundMatch: boundMatch,\n        boundOnInput: boundOnInput,\n        boundOnKeydown: boundOnKeydown,\n        boundSelect: boundSelect\n      })\n      var events = {\n        keydown: boundOnKeydown,\n        input: boundOnInput\n      }\n      events.blur = events[_AWE_CLOSE] = events[_AWE_LOAD] = boundMatch\n      events[_AWE_SELECT] = boundSelect\n      $.bind(elem, events)\n\n      awe.utilprops.detach = boundDetach\n      // Perform ajax call if prepop is true and there is an initial input value, or when all values must be loaded (loadall)\n      if (awe.utilprops.prepop && (awe.utilprops.loadall || elem.value.length > 0)) {\n        awe.utilprops.val = awe.utilprops.convertInput.call(awe, elem.value)\n        _lookup(awe, awe.utilprops.val)\n      }\n      return awe\n    },\n\n    // update input value via javascript. Use prepop=true when this is an initial/prepopulation value.\n    update: function (awe, value, prepop) {\n      awe.input.value = value\n      return _update(awe, value, prepop)\n    },\n\n    // create and attach Awesomplete object for input control elemId. opts are passed unchanged to Awesomplete.\n    start: function (elemId, utilOpts, opts) {\n      return this.attach(this.create(elemId, utilOpts, opts))\n    },\n\n    // Stop AwesompleteUtil; detach event handlers from the Awesomplete object.\n    detach: function (awe) {\n      if (awe.utilprops.detach) {\n        awe.utilprops.detach()\n        delete awe.utilprops.detach\n      }\n      return awe\n    },\n\n    // Create function to copy a field from the selected autocomplete item to another DOM element.\n    // dataField can be null.\n    createCopyFun: function (sourceId, dataField, targetId) {\n      return _copyFun.bind({ sourceId: sourceId, dataField: dataField, targetId: $(targetId) || targetId })\n    },\n\n    // attach copy function to event listeners. prepop is optional and by default true.\n    // if true the copy function will also listen to awesomplete-prepop events.\n    // The optional listenEl is the element that listens, defaults to document.body.\n    attachCopyFun: function (fun, prepop, listenEl) {\n      // prepop parameter defaults to true\n      prepop = typeof prepop === 'boolean' ? prepop : true\n      listenEl = listenEl || document.body\n      listenEl.addEventListener(_AWE_MATCH, fun)\n      if (prepop) listenEl.addEventListener(_AWE_PREPOP, fun)\n      return fun\n    },\n\n    // Create and attach copy function.\n    startCopy: function (sourceId, dataField, targetId, prepop) {\n      var sourceEl = $(sourceId)\n      return this.attachCopyFun(this.createCopyFun(sourceEl || sourceId, dataField, targetId), prepop, sourceEl)\n    },\n\n    // Stop copy function. Detach it from event listeners.\n    // The optional listenEl must be the same element that was used during startCopy/attachCopyFun;\n    // in general: Awesomplete.$(sourceId). listenEl defaults to document.body.\n    detachCopyFun: function (fun, listenEl) {\n      listenEl = listenEl || document.body\n      listenEl.removeEventListener(_AWE_PREPOP, fun)\n      listenEl.removeEventListener(_AWE_MATCH, fun)\n      return fun\n    },\n\n    // Create function for combobox button (btnId) to toggle dropdown list.\n    createClickFun: function (btnId, awe) {\n      return _clickFun.bind({ btnId: btnId, awe: awe })\n    },\n\n    // Attach click function for combobox to click event.\n    // The optional listenEl is the element that listens, defaults to document.body.\n    attachClickFun: function (fun, listenEl) {\n      listenEl = listenEl || document.body\n      listenEl.addEventListener('click', fun)\n      return fun\n    },\n\n    // Create and attach click function for combobox button. Toggles open/close of suggestion list.\n    startClick: function (btnId, awe) {\n      var btnEl = $(btnId)\n      return this.attachClickFun(this.createClickFun(btnEl || btnId, awe), btnEl)\n    },\n\n    // Stop click function. Detach it from event listeners.\n    // The optional listenEl must be the same element that was used during startClick/attachClickFun;\n    // in general: Awesomplete.$(btnId). listenEl defaults to document.body.\n    detachClickFun: function (fun, listenEl) {\n      listenEl = listenEl || document.body\n      listenEl.removeEventListener('click', fun)\n      return fun\n    },\n\n    // filter function as specified in Awesomplete. Filters suggestion list on items containing input value.\n    // Awesomplete.FILTER_CONTAINS filters on data.label, however\n    // this function filters on value and not on the shown label which may contain markup.\n    filterContains: function (data, input) {\n      return Awesomplete.FILTER_CONTAINS(data.value, input)\n    },\n\n    // filter function as specified in Awesomplete. Filters suggestion list on matching begin text.\n    // Awesomplete.FILTER_STARTSWITH filters on data.label, however\n    // this function filters on value and not on the shown label which may contain markup.\n    filterStartsWith: function (data, input) {\n      return Awesomplete.FILTER_STARTSWITH(data.value, input)\n    },\n\n    // Flatten JSON.\n    // { \"a\":{\"b\":{\"c\":[{\"d\":{\"e\":1}}]}}} becomes {\"a.b.c\":[{\"d.e\":1}]}.\n    // This function can be bind to configure it with extra options;\n    //   bind({root: '<root path>', value: '<value property>', label: '<label property>'})\n    jsonFlatten: function (data) {\n      // start json tree recursion\n      return _jsonFlatten({}, data, '', 0, this)\n    }\n  }\n}())\n\n\n//# sourceURL=webpack://blockscout/./js/lib/awesomplete-util.js?");
/******/ })()
;